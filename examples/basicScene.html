<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <script src="../build/three.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/libs/dat.gui.min.js"></script>

    <style type ="text/css">
        *{   margin: 0;padding: 0;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-size: 12px;
        }
        .wrapperDiv{
            /* overflow:hidden; */
            /* border:1px solid red; */
            height: 100%;
        }
        #sidebar{
            width: 200px;
            float:left;
        }
        .mapview{
            float: left;
            background-color: #fcf8e3;
            border:1px solid grey;
        }

    </style>
</head>
<body>
<div class="wrapperDiv">
    <div id="sidebar" style="position:absolute;">
        <p>고정폭 200px</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Porro inventore esse debitis voluptas labore ut quae veritatis reprehenderit ipsum.</p>
    </div>

    <div id="renderView" class="mapview" style="position:absolute;">
    </div>

</div>

<script>

    var scene;
    var camera;
    var renderer;

    var adjustWidth = 204;
    var adjustHeight = 4;

    function initStats(){
        var stats = new Stats();

        stats.setMode(0); // 0: fps, 1: ms

        // Align top-left
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.getElementById("renderView").appendChild(stats.domElement);

        return stats;
    }

    function init(){

        var stats = initStats();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.window.renderWidth / window.window.renderHeight, 0.1, 1000);
        scene.add(camera);

        // create a render and set the size
        renderer = new THREE.WebGLRenderer();

        // renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
        renderer.setClearColor(new THREE.Color(0xEEEEEE), 1.0);
        //renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setSize(window.renderWidth, window.renderHeight );
        renderer.shadowMapEnabled = true;

        // create the ground plane
        // var planeGeometry = new THREE.PlaneGeometry(60, 40, 1, 1);
        var planeGeometry = new THREE.PlaneBufferGeometry( 60, 40);

        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff});
        // var planeMaterial = new THREE.MeshPhongMaterial( { color: 0x000066 } );
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;

        // rotate and position the plane
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.x = 0;
        plane.position.y = 0;
        plane.position.z = 0;

        // add the plane to the scene
        scene.add(plane);

        // position and point the camera to the center of the scene
        camera.position.x = -30;
        camera.position.y = 40;
        camera.position.z = 30;
        camera.lookAt(scene.position);

        // add subtle ambient lighting
        var ambientLight = new THREE.AmbientLight(0x0c0c0c);
        scene.add(ambientLight);

        // add spotlight for the shadows
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-40, 60, -10);
        spotLight.castShadow = true;
        scene.add(spotLight);

        // add the output of the renderer to the html element
       document.getElementById("renderView").appendChild(renderer.domElement);

        // call the render function
        var step = 0;


        var controls = new function ()
        {
            this.rotationSpeed = 0.02;
            this.numberOfObjects = scene.children.length;

            this.removeCube = function ()
            {
                var allChildren = scene.children;
                var lastObject = allChildren[allChildren.length - 1];
                if (lastObject instanceof THREE.Mesh)
                {
                    scene.remove(lastObject);
                    this.numberOfObjects = scene.children.length;
                }

                console.log( "Called removeCube !!  count: " + allChildren.length );
            };

            this.addCube = function ()
            {
                var cubeSize = Math.ceil((Math.random() * 3));
                var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                var cubeMaterial = new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff});
                var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.castShadow = true;
                cube.receiveShadow = true;
                cube.name = "cube-" + scene.children.length;


                // position the cube randomly in the scene
                // Math.round : �ݿø�
                // Math.ceil : �ø�
                // Math.floor : ����
                cube.position.x = -30 + Math.round((Math.random() * planeGeometry.parameters.width));
                cube.position.y = Math.round((Math.random() * 5));
                cube.position.z = -20 + Math.round((Math.random() * planeGeometry.parameters.height));

                // add the cube to the scene
                scene.add(cube);
                this.numberOfObjects = scene.children.length;

                console.log( "Called addCube !!  count: " + scene.children.length );

            };

            this.outputObjects = function ()
            {
                console.log(scene.children);
            }
        };


        var gui = new dat.GUI();
        gui.add(controls, 'rotationSpeed', 0, 0.5);
        gui.add(controls, 'addCube');
        gui.add(controls, 'removeCube');
        gui.add(controls, 'outputObjects');
        gui.add(controls, 'numberOfObjects').listen();

        render();

        function render()
        {
            stats.update();

            // rotate the cubes around its axes
            scene.traverse( function (e)
            {
                if (e instanceof THREE.Mesh && e != plane)
                {
                    // console.log( "Element Type : " + e.type + "e.id " + e.id );
                    e.rotation.x += controls.rotationSpeed;
                    e.rotation.y += controls.rotationSpeed;
                    e.rotation.z += controls.rotationSpeed;
                }
            });

            // render using requestAnimationFrame
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }
    }



    var adjustScrDiv = (function(){

        var bIsFullScr = 'false';

        function fullScrMap(){
            var sidebar = document.getElementById('sidebar');
            var mapview = document.getElementById('renderView');

            var toggleBtn = document.getElementById("footerToggle");
            toggleBtn.style.left = ( window.innerWidth * 0.5 ) + "px";
            toggleBtn.style.top = (window.innerHeight - 13)+ "px";


            sidebar.style.bottom = 0 + 'px';

            mapview.style.left = 200+'px';
            mapview.style.right = 0 + 'px';
            mapview.style.bottom = 0 + 'px';
        }

        function normalScrMap(){
            var sidebar = document.getElementById('sidebar');
            var mapview = document.getElementById('renderView');
            var footer = document.getElementById('footer');

            var mapHeight = window.innerHeight * 0.65;

            sidebar.style.top = 0;
            sidebar.style.bottom = ( window.innerHeight- ( window.innerHeight * 0.65 )) + 'px';
            mapview.style.left = 200+'px';
            mapview.style.right = 0 + 'px';
            mapview.style.top = 0 + 'px';
            mapview.style.bottom = 0 + 'px';
        }

        function showScrMap( ){

            var img1 = "hideBible.png";
            var img2 = "showBible.png";

            var toggleBtn = document.getElementById("footerToggle");

            if( bIsFullScr == 'false' ) {
                adjustScrDiv.normalScrMap();
                toggleBtn.src = img1;
            }
            else{
                adjustScrDiv.fullScrMap();
                toggleBtn.src = img2;
            }

            map.updateSize();
        }

        function toggleScrMap(){

            if( bIsFullScr == 'false'){
                bIsFullScr = 'true';
            }
            else{
                bIsFullScr = 'false';
            }
            showScrMap();
        }

        return {
            fullScrMap : fullScrMap,
            normalScrMap : normalScrMap,
            showScrMap : showScrMap,
            toggleScrMap : toggleScrMap
        };

    }());

    function toggleScrMap(){
        adjustScrDiv.toggleScrMap();
    }

    window.onload = function(){

        window.renderWidth = window.innerWidth - adjustWidth;
        window.renderHeight = window.innerHeight - adjustHeight;

        init();
        adjustScrDiv.normalScrMap();
    };

    window.onresize = function(){

        window.renderWidth = window.innerWidth - adjustWidth;
        window.renderHeight = window.innerHeight - adjustHeight;

        if( camera ) {
            // camera.aspect = window.innerWidth / window.innerHeight;
            camera.aspect = window.renderWidth / window.renderHeight;
            camera.updateProjectionMatrix();
        }

        if( renderer ) {
            // renderer.setSize(window.innerWidth-adjustWidth, window.innerHeight-adjustHeight);
            renderer.setSize( window.renderWidth, window.renderHeight );
        }

        adjustScrDiv.showScrMap();
    }


</script>

</body>
</html>